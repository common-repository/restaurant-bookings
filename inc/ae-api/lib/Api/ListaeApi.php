<?php
/**
 * ListaeApi
 * PHP version 5
 *
 * @category Class
 * @package  Listae\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * listae API 2.0
 *
 * Documentación de los servicios REST de listae
 *
 * OpenAPI spec version: 2.0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.23
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Listae\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Listae\Client\ApiException;
use Listae\Client\Configuration;
use Listae\Client\HeaderSelector;
use Listae\Client\ObjectSerializer;

/**
 * ListaeApi Class Doc Comment
 *
 * @category Class
 * @package  Listae\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ListaeApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation contactToBusiness
     *
     * @param  \Listae\Client\Model\ContactInput $body Datos del formulario de contacto (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\BusinessMini
     */
    public function contactToBusiness($body, $bss_slug, $accept_language = 'es')
    {
        list($response) = $this->contactToBusinessWithHttpInfo($body, $bss_slug, $accept_language);
        return $response;
    }

    /**
     * Operation contactToBusinessWithHttpInfo
     *
     * @param  \Listae\Client\Model\ContactInput $body Datos del formulario de contacto (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\BusinessMini, HTTP status code, HTTP response headers (array of strings)
     */
    public function contactToBusinessWithHttpInfo($body, $bss_slug, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\BusinessMini';
        $request = $this->contactToBusinessRequest($body, $bss_slug, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\BusinessMini',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\InputError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation contactToBusinessAsync
     *
     * 
     *
     * @param  \Listae\Client\Model\ContactInput $body Datos del formulario de contacto (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contactToBusinessAsync($body, $bss_slug, $accept_language = 'es')
    {
        return $this->contactToBusinessAsyncWithHttpInfo($body, $bss_slug, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation contactToBusinessAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Listae\Client\Model\ContactInput $body Datos del formulario de contacto (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contactToBusinessAsyncWithHttpInfo($body, $bss_slug, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\BusinessMini';
        $request = $this->contactToBusinessRequest($body, $bss_slug, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'contactToBusiness'
     *
     * @param  \Listae\Client\Model\ContactInput $body Datos del formulario de contacto (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function contactToBusinessRequest($body, $bss_slug, $accept_language = 'es')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling contactToBusiness'
            );
        }
        // verify the required parameter 'bss_slug' is set
        if ($bss_slug === null || (is_array($bss_slug) && count($bss_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bss_slug when calling contactToBusiness'
            );
        }

        $resourcePath = '/restaurants/{bss-slug}/contact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($bss_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'bss-slug' . '}',
                ObjectSerializer::toPathValue($bss_slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarte
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $carte_id El identificador de la carta. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Catalog
     */
    public function getCarte($restaurant_id, $carte_id, $accept_language = 'es')
    {
        list($response) = $this->getCarteWithHttpInfo($restaurant_id, $carte_id, $accept_language);
        return $response;
    }

    /**
     * Operation getCarteWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $carte_id El identificador de la carta. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Catalog, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCarteWithHttpInfo($restaurant_id, $carte_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Catalog';
        $request = $this->getCarteRequest($restaurant_id, $carte_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Catalog',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCarteAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $carte_id El identificador de la carta. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarteAsync($restaurant_id, $carte_id, $accept_language = 'es')
    {
        return $this->getCarteAsyncWithHttpInfo($restaurant_id, $carte_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $carte_id El identificador de la carta. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarteAsyncWithHttpInfo($restaurant_id, $carte_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Catalog';
        $request = $this->getCarteRequest($restaurant_id, $carte_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarte'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $carte_id El identificador de la carta. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarteRequest($restaurant_id, $carte_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getCarte'
            );
        }
        // verify the required parameter 'carte_id' is set
        if ($carte_id === null || (is_array($carte_id) && count($carte_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $carte_id when calling getCarte'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/cartes/{carte-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }
        // path params
        if ($carte_id !== null) {
            $resourcePath = str_replace(
                '{' . 'carte-id' . '}',
                ObjectSerializer::toPathValue($carte_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarteGroup
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de la carta. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\CatalogItemGroup
     */
    public function getCarteGroup($restaurant_id, $group_id, $accept_language = 'es')
    {
        list($response) = $this->getCarteGroupWithHttpInfo($restaurant_id, $group_id, $accept_language);
        return $response;
    }

    /**
     * Operation getCarteGroupWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de la carta. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\CatalogItemGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCarteGroupWithHttpInfo($restaurant_id, $group_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\CatalogItemGroup';
        $request = $this->getCarteGroupRequest($restaurant_id, $group_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\CatalogItemGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCarteGroupAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de la carta. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarteGroupAsync($restaurant_id, $group_id, $accept_language = 'es')
    {
        return $this->getCarteGroupAsyncWithHttpInfo($restaurant_id, $group_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarteGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de la carta. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarteGroupAsyncWithHttpInfo($restaurant_id, $group_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\CatalogItemGroup';
        $request = $this->getCarteGroupRequest($restaurant_id, $group_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarteGroup'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de la carta. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarteGroupRequest($restaurant_id, $group_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getCarteGroup'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getCarteGroup'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/cartes/groups/{group-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCartes
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Cartes
     */
    public function getCartes($restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->getCartesWithHttpInfo($restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation getCartesWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Cartes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCartesWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Cartes';
        $request = $this->getCartesRequest($restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Cartes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCartesAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCartesAsync($restaurant_id, $accept_language = 'es')
    {
        return $this->getCartesAsyncWithHttpInfo($restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCartesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCartesAsyncWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Cartes';
        $request = $this->getCartesRequest($restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCartes'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCartesRequest($restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getCartes'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/cartes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCategoryFilterRoot
     *
     * Recuperacion de filtros de categoríás
     *
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\CategoryFilterRoot
     */
    public function getCategoryFilterRoot($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $slugs = null, $geocodes = null)
    {
        list($response) = $this->getCategoryFilterRootWithHttpInfo($accept_language, $n, $q, $l, $r, $t, $c, $cat, $tag, $lat, $lon, $dst, $s, $sc, $hcl, $slugs, $geocodes);
        return $response;
    }

    /**
     * Operation getCategoryFilterRootWithHttpInfo
     *
     * Recuperacion de filtros de categoríás
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\CategoryFilterRoot, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCategoryFilterRootWithHttpInfo($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $slugs = null, $geocodes = null)
    {
        $returnType = '\Listae\Client\Model\CategoryFilterRoot';
        $request = $this->getCategoryFilterRootRequest($accept_language, $n, $q, $l, $r, $t, $c, $cat, $tag, $lat, $lon, $dst, $s, $sc, $hcl, $slugs, $geocodes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\CategoryFilterRoot',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCategoryFilterRootAsync
     *
     * Recuperacion de filtros de categoríás
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoryFilterRootAsync($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $slugs = null, $geocodes = null)
    {
        return $this->getCategoryFilterRootAsyncWithHttpInfo($accept_language, $n, $q, $l, $r, $t, $c, $cat, $tag, $lat, $lon, $dst, $s, $sc, $hcl, $slugs, $geocodes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCategoryFilterRootAsyncWithHttpInfo
     *
     * Recuperacion de filtros de categoríás
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoryFilterRootAsyncWithHttpInfo($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $slugs = null, $geocodes = null)
    {
        $returnType = '\Listae\Client\Model\CategoryFilterRoot';
        $request = $this->getCategoryFilterRootRequest($accept_language, $n, $q, $l, $r, $t, $c, $cat, $tag, $lat, $lon, $dst, $s, $sc, $hcl, $slugs, $geocodes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCategoryFilterRoot'
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCategoryFilterRootRequest($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $slugs = null, $geocodes = null)
    {

        $resourcePath = '/search/categories/filter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($n !== null) {
            $queryParams['n'] = ObjectSerializer::toQueryValue($n, null);
        }
        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q, null);
        }
        // query params
        if ($l !== null) {
            $queryParams['l'] = ObjectSerializer::toQueryValue($l, null);
        }
        // query params
        if ($r !== null) {
            $queryParams['r'] = ObjectSerializer::toQueryValue($r, null);
        }
        // query params
        if ($t !== null) {
            $queryParams['t'] = ObjectSerializer::toQueryValue($t, null);
        }
        // query params
        if ($c !== null) {
            $queryParams['c'] = ObjectSerializer::toQueryValue($c, null);
        }
        // query params
        if (is_array($cat)) {
            $cat = ObjectSerializer::serializeCollection($cat, 'multi', true);
        }
        if ($cat !== null) {
            $queryParams['cat'] = ObjectSerializer::toQueryValue($cat, null);
        }
        // query params
        if (is_array($tag)) {
            $tag = ObjectSerializer::serializeCollection($tag, 'multi', true);
        }
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag, null);
        }
        // query params
        if ($lat !== null) {
            $queryParams['lat'] = ObjectSerializer::toQueryValue($lat, 'float');
        }
        // query params
        if ($lon !== null) {
            $queryParams['lon'] = ObjectSerializer::toQueryValue($lon, 'float');
        }
        // query params
        if ($dst !== null) {
            $queryParams['dst'] = ObjectSerializer::toQueryValue($dst, 'int64');
        }
        // query params
        if ($s !== null) {
            $queryParams['s'] = ObjectSerializer::toQueryValue($s, 'int64');
        }
        // query params
        if ($sc !== null) {
            $queryParams['sc'] = ObjectSerializer::toQueryValue($sc, 'int64');
        }
        // query params
        if ($hcl !== null) {
            $queryParams['hcl'] = ObjectSerializer::toQueryValue($hcl, null);
        }
        // query params
        if ($slugs !== null) {
            $queryParams['slugs'] = ObjectSerializer::toQueryValue($slugs, null);
        }
        // query params
        if ($geocodes !== null) {
            $queryParams['geocodes'] = ObjectSerializer::toQueryValue($geocodes, null);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCoupon
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $coupon_id El identificador del cupon. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Coupon
     */
    public function getCoupon($restaurant_id, $coupon_id, $accept_language = 'es')
    {
        list($response) = $this->getCouponWithHttpInfo($restaurant_id, $coupon_id, $accept_language);
        return $response;
    }

    /**
     * Operation getCouponWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $coupon_id El identificador del cupon. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Coupon, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCouponWithHttpInfo($restaurant_id, $coupon_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Coupon';
        $request = $this->getCouponRequest($restaurant_id, $coupon_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Coupon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCouponAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $coupon_id El identificador del cupon. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponAsync($restaurant_id, $coupon_id, $accept_language = 'es')
    {
        return $this->getCouponAsyncWithHttpInfo($restaurant_id, $coupon_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCouponAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $coupon_id El identificador del cupon. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponAsyncWithHttpInfo($restaurant_id, $coupon_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Coupon';
        $request = $this->getCouponRequest($restaurant_id, $coupon_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCoupon'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $coupon_id El identificador del cupon. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCouponRequest($restaurant_id, $coupon_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getCoupon'
            );
        }
        // verify the required parameter 'coupon_id' is set
        if ($coupon_id === null || (is_array($coupon_id) && count($coupon_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $coupon_id when calling getCoupon'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/coupons/{coupon-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }
        // path params
        if ($coupon_id !== null) {
            $resourcePath = str_replace(
                '{' . 'coupon-id' . '}',
                ObjectSerializer::toPathValue($coupon_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCoupons
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\CouponList
     */
    public function getCoupons($restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->getCouponsWithHttpInfo($restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation getCouponsWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\CouponList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCouponsWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\CouponList';
        $request = $this->getCouponsRequest($restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\CouponList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCouponsAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsAsync($restaurant_id, $accept_language = 'es')
    {
        return $this->getCouponsAsyncWithHttpInfo($restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCouponsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsAsyncWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\CouponList';
        $request = $this->getCouponsRequest($restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCoupons'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCouponsRequest($restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getCoupons'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/coupons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeliveryCfg
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\DeliveryCfg
     */
    public function getDeliveryCfg($restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->getDeliveryCfgWithHttpInfo($restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation getDeliveryCfgWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\DeliveryCfg, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeliveryCfgWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\DeliveryCfg';
        $request = $this->getDeliveryCfgRequest($restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\DeliveryCfg',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeliveryCfgAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeliveryCfgAsync($restaurant_id, $accept_language = 'es')
    {
        return $this->getDeliveryCfgAsyncWithHttpInfo($restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeliveryCfgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeliveryCfgAsyncWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\DeliveryCfg';
        $request = $this->getDeliveryCfgRequest($restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeliveryCfg'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeliveryCfgRequest($restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getDeliveryCfg'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/delivery';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMenu
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $menu_id El identificador del menú. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Menu
     */
    public function getMenu($restaurant_id, $menu_id, $accept_language = 'es')
    {
        list($response) = $this->getMenuWithHttpInfo($restaurant_id, $menu_id, $accept_language);
        return $response;
    }

    /**
     * Operation getMenuWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $menu_id El identificador del menú. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Menu, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMenuWithHttpInfo($restaurant_id, $menu_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Menu';
        $request = $this->getMenuRequest($restaurant_id, $menu_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Menu',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMenuAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $menu_id El identificador del menú. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuAsync($restaurant_id, $menu_id, $accept_language = 'es')
    {
        return $this->getMenuAsyncWithHttpInfo($restaurant_id, $menu_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMenuAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $menu_id El identificador del menú. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuAsyncWithHttpInfo($restaurant_id, $menu_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Menu';
        $request = $this->getMenuRequest($restaurant_id, $menu_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMenu'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $menu_id El identificador del menú. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMenuRequest($restaurant_id, $menu_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getMenu'
            );
        }
        // verify the required parameter 'menu_id' is set
        if ($menu_id === null || (is_array($menu_id) && count($menu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $menu_id when calling getMenu'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/menus/{menu-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }
        // path params
        if ($menu_id !== null) {
            $resourcePath = str_replace(
                '{' . 'menu-id' . '}',
                ObjectSerializer::toPathValue($menu_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMenuGroup
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de menús. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\CatalogItemGroup
     */
    public function getMenuGroup($restaurant_id, $group_id, $accept_language = 'es')
    {
        list($response) = $this->getMenuGroupWithHttpInfo($restaurant_id, $group_id, $accept_language);
        return $response;
    }

    /**
     * Operation getMenuGroupWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de menús. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\CatalogItemGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMenuGroupWithHttpInfo($restaurant_id, $group_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\CatalogItemGroup';
        $request = $this->getMenuGroupRequest($restaurant_id, $group_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\CatalogItemGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMenuGroupAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de menús. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuGroupAsync($restaurant_id, $group_id, $accept_language = 'es')
    {
        return $this->getMenuGroupAsyncWithHttpInfo($restaurant_id, $group_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMenuGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de menús. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuGroupAsyncWithHttpInfo($restaurant_id, $group_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\CatalogItemGroup';
        $request = $this->getMenuGroupRequest($restaurant_id, $group_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMenuGroup'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  int $group_id El identificador del grupo de menús. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMenuGroupRequest($restaurant_id, $group_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getMenuGroup'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getMenuGroup'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/menus/groups/{group-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMenus
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Menus
     */
    public function getMenus($restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->getMenusWithHttpInfo($restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation getMenusWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Menus, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMenusWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Menus';
        $request = $this->getMenusRequest($restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Menus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMenusAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenusAsync($restaurant_id, $accept_language = 'es')
    {
        return $this->getMenusAsyncWithHttpInfo($restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMenusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenusAsyncWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Menus';
        $request = $this->getMenusRequest($restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMenus'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMenusRequest($restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getMenus'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/menus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMenusBooking
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Menus
     */
    public function getMenusBooking($restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->getMenusBookingWithHttpInfo($restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation getMenusBookingWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Menus, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMenusBookingWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Menus';
        $request = $this->getMenusBookingRequest($restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Menus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMenusBookingAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenusBookingAsync($restaurant_id, $accept_language = 'es')
    {
        return $this->getMenusBookingAsyncWithHttpInfo($restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMenusBookingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenusBookingAsyncWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Menus';
        $request = $this->getMenusBookingRequest($restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMenusBooking'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMenusBookingRequest($restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getMenusBooking'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/menus/bookable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderCfg
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\OrderCfg
     */
    public function getOrderCfg($restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->getOrderCfgWithHttpInfo($restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation getOrderCfgWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\OrderCfg, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderCfgWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\OrderCfg';
        $request = $this->getOrderCfgRequest($restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\OrderCfg',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderCfgAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderCfgAsync($restaurant_id, $accept_language = 'es')
    {
        return $this->getOrderCfgAsyncWithHttpInfo($restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderCfgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderCfgAsyncWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\OrderCfg';
        $request = $this->getOrderCfgRequest($restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderCfg'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderCfgRequest($restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getOrderCfg'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderDetail
     *
     * @param  string $localizator El identificador del localizador del pedido (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\OrderDetail
     */
    public function getOrderDetail($localizator, $accept_language = 'es')
    {
        list($response) = $this->getOrderDetailWithHttpInfo($localizator, $accept_language);
        return $response;
    }

    /**
     * Operation getOrderDetailWithHttpInfo
     *
     * @param  string $localizator El identificador del localizador del pedido (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\OrderDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderDetailWithHttpInfo($localizator, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\OrderDetail';
        $request = $this->getOrderDetailRequest($localizator, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\OrderDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderDetailAsync
     *
     * 
     *
     * @param  string $localizator El identificador del localizador del pedido (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderDetailAsync($localizator, $accept_language = 'es')
    {
        return $this->getOrderDetailAsyncWithHttpInfo($localizator, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderDetailAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $localizator El identificador del localizador del pedido (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderDetailAsyncWithHttpInfo($localizator, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\OrderDetail';
        $request = $this->getOrderDetailRequest($localizator, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderDetail'
     *
     * @param  string $localizator El identificador del localizador del pedido (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderDetailRequest($localizator, $accept_language = 'es')
    {
        // verify the required parameter 'localizator' is set
        if ($localizator === null || (is_array($localizator) && count($localizator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $localizator when calling getOrderDetail'
            );
        }

        $resourcePath = '/restaurants/order/detail/{localizator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($localizator !== null) {
            $resourcePath = str_replace(
                '{' . 'localizator' . '}',
                ObjectSerializer::toPathValue($localizator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPost
     *
     * @param  int $post_id El identificador de la publicacion. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Post
     */
    public function getPost($post_id, $accept_language = 'es')
    {
        list($response) = $this->getPostWithHttpInfo($post_id, $accept_language);
        return $response;
    }

    /**
     * Operation getPostWithHttpInfo
     *
     * @param  int $post_id El identificador de la publicacion. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Post, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPostWithHttpInfo($post_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Post';
        $request = $this->getPostRequest($post_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Post',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPostAsync
     *
     * 
     *
     * @param  int $post_id El identificador de la publicacion. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPostAsync($post_id, $accept_language = 'es')
    {
        return $this->getPostAsyncWithHttpInfo($post_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $post_id El identificador de la publicacion. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPostAsyncWithHttpInfo($post_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Post';
        $request = $this->getPostRequest($post_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPost'
     *
     * @param  int $post_id El identificador de la publicacion. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPostRequest($post_id, $accept_language = 'es')
    {
        // verify the required parameter 'post_id' is set
        if ($post_id === null || (is_array($post_id) && count($post_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_id when calling getPost'
            );
        }

        $resourcePath = '/posts/detail/{post-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($post_id !== null) {
            $resourcePath = str_replace(
                '{' . 'post-id' . '}',
                ObjectSerializer::toPathValue($post_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRestaurant
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Restaurant
     */
    public function getRestaurant($restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->getRestaurantWithHttpInfo($restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation getRestaurantWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Restaurant, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRestaurantWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Restaurant';
        $request = $this->getRestaurantRequest($restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Restaurant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRestaurantAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRestaurantAsync($restaurant_id, $accept_language = 'es')
    {
        return $this->getRestaurantAsyncWithHttpInfo($restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRestaurantAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRestaurantAsyncWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Restaurant';
        $request = $this->getRestaurantRequest($restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRestaurant'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRestaurantRequest($restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getRestaurant'
            );
        }

        $resourcePath = '/restaurants/detail/{restaurant-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTakeawayCfg
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\TakeawayCfg
     */
    public function getTakeawayCfg($restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->getTakeawayCfgWithHttpInfo($restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation getTakeawayCfgWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\TakeawayCfg, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTakeawayCfgWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\TakeawayCfg';
        $request = $this->getTakeawayCfgRequest($restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\TakeawayCfg',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTakeawayCfgAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTakeawayCfgAsync($restaurant_id, $accept_language = 'es')
    {
        return $this->getTakeawayCfgAsyncWithHttpInfo($restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTakeawayCfgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTakeawayCfgAsyncWithHttpInfo($restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\TakeawayCfg';
        $request = $this->getTakeawayCfgRequest($restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTakeawayCfg'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTakeawayCfgRequest($restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling getTakeawayCfg'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/takeaway';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertBooking
     *
     * @param  \Listae\Client\Model\BookingInput $body Reserva a registrar (required)
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Booking
     */
    public function insertBooking($body, $restaurant_id, $accept_language = 'es')
    {
        list($response) = $this->insertBookingWithHttpInfo($body, $restaurant_id, $accept_language);
        return $response;
    }

    /**
     * Operation insertBookingWithHttpInfo
     *
     * @param  \Listae\Client\Model\BookingInput $body Reserva a registrar (required)
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Booking, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertBookingWithHttpInfo($body, $restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Booking';
        $request = $this->insertBookingRequest($body, $restaurant_id, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Booking',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\InputError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertBookingAsync
     *
     * 
     *
     * @param  \Listae\Client\Model\BookingInput $body Reserva a registrar (required)
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertBookingAsync($body, $restaurant_id, $accept_language = 'es')
    {
        return $this->insertBookingAsyncWithHttpInfo($body, $restaurant_id, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertBookingAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Listae\Client\Model\BookingInput $body Reserva a registrar (required)
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertBookingAsyncWithHttpInfo($body, $restaurant_id, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\Booking';
        $request = $this->insertBookingRequest($body, $restaurant_id, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertBooking'
     *
     * @param  \Listae\Client\Model\BookingInput $body Reserva a registrar (required)
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertBookingRequest($body, $restaurant_id, $accept_language = 'es')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling insertBooking'
            );
        }
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling insertBooking'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/booking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertBusinessReview
     *
     * @param  \Listae\Client\Model\ReviewInput $body Datos del formulario de opinar (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\BusinessMini
     */
    public function insertBusinessReview($body, $bss_slug, $accept_language = 'es')
    {
        list($response) = $this->insertBusinessReviewWithHttpInfo($body, $bss_slug, $accept_language);
        return $response;
    }

    /**
     * Operation insertBusinessReviewWithHttpInfo
     *
     * @param  \Listae\Client\Model\ReviewInput $body Datos del formulario de opinar (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\BusinessMini, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertBusinessReviewWithHttpInfo($body, $bss_slug, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\BusinessMini';
        $request = $this->insertBusinessReviewRequest($body, $bss_slug, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\BusinessMini',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\InputError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertBusinessReviewAsync
     *
     * 
     *
     * @param  \Listae\Client\Model\ReviewInput $body Datos del formulario de opinar (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertBusinessReviewAsync($body, $bss_slug, $accept_language = 'es')
    {
        return $this->insertBusinessReviewAsyncWithHttpInfo($body, $bss_slug, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertBusinessReviewAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Listae\Client\Model\ReviewInput $body Datos del formulario de opinar (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertBusinessReviewAsyncWithHttpInfo($body, $bss_slug, $accept_language = 'es')
    {
        $returnType = '\Listae\Client\Model\BusinessMini';
        $request = $this->insertBusinessReviewRequest($body, $bss_slug, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertBusinessReview'
     *
     * @param  \Listae\Client\Model\ReviewInput $body Datos del formulario de opinar (required)
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertBusinessReviewRequest($body, $bss_slug, $accept_language = 'es')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling insertBusinessReview'
            );
        }
        // verify the required parameter 'bss_slug' is set
        if ($bss_slug === null || (is_array($bss_slug) && count($bss_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bss_slug when calling insertBusinessReview'
            );
        }

        $resourcePath = '/restaurants/{bss-slug}/review';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($bss_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'bss-slug' . '}',
                ObjectSerializer::toPathValue($bss_slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation offerFind
     *
     * Busca de ofertas por usuario.
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  string $e Email del cliente (optional)
     * @param  string $cc Codigo del pais del telefono de usuario (optional)
     * @param  string $pn Telefono del usuario (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\OfferList
     */
    public function offerFind($bss_slug, $accept_language = 'es', $e = null, $cc = null, $pn = null)
    {
        list($response) = $this->offerFindWithHttpInfo($bss_slug, $accept_language, $e, $cc, $pn);
        return $response;
    }

    /**
     * Operation offerFindWithHttpInfo
     *
     * Busca de ofertas por usuario.
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $e Email del cliente (optional)
     * @param  string $cc Codigo del pais del telefono de usuario (optional)
     * @param  string $pn Telefono del usuario (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\OfferList, HTTP status code, HTTP response headers (array of strings)
     */
    public function offerFindWithHttpInfo($bss_slug, $accept_language = 'es', $e = null, $cc = null, $pn = null)
    {
        $returnType = '\Listae\Client\Model\OfferList';
        $request = $this->offerFindRequest($bss_slug, $accept_language, $e, $cc, $pn);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\OfferList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation offerFindAsync
     *
     * Busca de ofertas por usuario.
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $e Email del cliente (optional)
     * @param  string $cc Codigo del pais del telefono de usuario (optional)
     * @param  string $pn Telefono del usuario (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function offerFindAsync($bss_slug, $accept_language = 'es', $e = null, $cc = null, $pn = null)
    {
        return $this->offerFindAsyncWithHttpInfo($bss_slug, $accept_language, $e, $cc, $pn)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation offerFindAsyncWithHttpInfo
     *
     * Busca de ofertas por usuario.
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $e Email del cliente (optional)
     * @param  string $cc Codigo del pais del telefono de usuario (optional)
     * @param  string $pn Telefono del usuario (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function offerFindAsyncWithHttpInfo($bss_slug, $accept_language = 'es', $e = null, $cc = null, $pn = null)
    {
        $returnType = '\Listae\Client\Model\OfferList';
        $request = $this->offerFindRequest($bss_slug, $accept_language, $e, $cc, $pn);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'offerFind'
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $e Email del cliente (optional)
     * @param  string $cc Codigo del pais del telefono de usuario (optional)
     * @param  string $pn Telefono del usuario (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function offerFindRequest($bss_slug, $accept_language = 'es', $e = null, $cc = null, $pn = null)
    {
        // verify the required parameter 'bss_slug' is set
        if ($bss_slug === null || (is_array($bss_slug) && count($bss_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bss_slug when calling offerFind'
            );
        }

        $resourcePath = '/offer/{bss-slug}/user/find';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($e !== null) {
            $queryParams['e'] = ObjectSerializer::toQueryValue($e, null);
        }
        // query params
        if ($cc !== null) {
            $queryParams['cc'] = ObjectSerializer::toQueryValue($cc, null);
        }
        // query params
        if ($pn !== null) {
            $queryParams['pn'] = ObjectSerializer::toQueryValue($pn, null);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($bss_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'bss-slug' . '}',
                ObjectSerializer::toPathValue($bss_slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation offerGet
     *
     * Detalle de oferta
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  string $oc Codigo de la oferta (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\Offer
     */
    public function offerGet($bss_slug, $accept_language = 'es', $oc = null)
    {
        list($response) = $this->offerGetWithHttpInfo($bss_slug, $accept_language, $oc);
        return $response;
    }

    /**
     * Operation offerGetWithHttpInfo
     *
     * Detalle de oferta
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $oc Codigo de la oferta (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\Offer, HTTP status code, HTTP response headers (array of strings)
     */
    public function offerGetWithHttpInfo($bss_slug, $accept_language = 'es', $oc = null)
    {
        $returnType = '\Listae\Client\Model\Offer';
        $request = $this->offerGetRequest($bss_slug, $accept_language, $oc);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\Offer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation offerGetAsync
     *
     * Detalle de oferta
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $oc Codigo de la oferta (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function offerGetAsync($bss_slug, $accept_language = 'es', $oc = null)
    {
        return $this->offerGetAsyncWithHttpInfo($bss_slug, $accept_language, $oc)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation offerGetAsyncWithHttpInfo
     *
     * Detalle de oferta
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $oc Codigo de la oferta (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function offerGetAsyncWithHttpInfo($bss_slug, $accept_language = 'es', $oc = null)
    {
        $returnType = '\Listae\Client\Model\Offer';
        $request = $this->offerGetRequest($bss_slug, $accept_language, $oc);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'offerGet'
     *
     * @param  string $bss_slug El identificador del negocio, por ejemplo, un-restaurante-cualquiera (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $oc Codigo de la oferta (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function offerGetRequest($bss_slug, $accept_language = 'es', $oc = null)
    {
        // verify the required parameter 'bss_slug' is set
        if ($bss_slug === null || (is_array($bss_slug) && count($bss_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bss_slug when calling offerGet'
            );
        }

        $resourcePath = '/offer/{bss-slug}/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($oc !== null) {
            $queryParams['oc'] = ObjectSerializer::toQueryValue($oc, null);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($bss_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'bss-slug' . '}',
                ObjectSerializer::toPathValue($bss_slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCategories
     *
     * Buscador de categorías
     *
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  string $n Filtro de nombre de la categoria a buscar (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\BasicList
     */
    public function searchCategories($accept_language = 'es', $n = null)
    {
        list($response) = $this->searchCategoriesWithHttpInfo($accept_language, $n);
        return $response;
    }

    /**
     * Operation searchCategoriesWithHttpInfo
     *
     * Buscador de categorías
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro de nombre de la categoria a buscar (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\BasicList, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCategoriesWithHttpInfo($accept_language = 'es', $n = null)
    {
        $returnType = '\Listae\Client\Model\BasicList';
        $request = $this->searchCategoriesRequest($accept_language, $n);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\BasicList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchCategoriesAsync
     *
     * Buscador de categorías
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro de nombre de la categoria a buscar (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCategoriesAsync($accept_language = 'es', $n = null)
    {
        return $this->searchCategoriesAsyncWithHttpInfo($accept_language, $n)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCategoriesAsyncWithHttpInfo
     *
     * Buscador de categorías
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro de nombre de la categoria a buscar (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCategoriesAsyncWithHttpInfo($accept_language = 'es', $n = null)
    {
        $returnType = '\Listae\Client\Model\BasicList';
        $request = $this->searchCategoriesRequest($accept_language, $n);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCategories'
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro de nombre de la categoria a buscar (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchCategoriesRequest($accept_language = 'es', $n = null)
    {

        $resourcePath = '/search/restaurants/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($n !== null) {
            $queryParams['n'] = ObjectSerializer::toQueryValue($n, null);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchMyRestaurants
     *
     * Busca restaurantes propios
     *
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  string $n Filtro por nombre de los restaurantes (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\SearchFilter
     */
    public function searchMyRestaurants($accept_language = 'es', $n = null)
    {
        list($response) = $this->searchMyRestaurantsWithHttpInfo($accept_language, $n);
        return $response;
    }

    /**
     * Operation searchMyRestaurantsWithHttpInfo
     *
     * Busca restaurantes propios
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por nombre de los restaurantes (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\SearchFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchMyRestaurantsWithHttpInfo($accept_language = 'es', $n = null)
    {
        $returnType = '\Listae\Client\Model\SearchFilter';
        $request = $this->searchMyRestaurantsRequest($accept_language, $n);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\SearchFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchMyRestaurantsAsync
     *
     * Busca restaurantes propios
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por nombre de los restaurantes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMyRestaurantsAsync($accept_language = 'es', $n = null)
    {
        return $this->searchMyRestaurantsAsyncWithHttpInfo($accept_language, $n)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchMyRestaurantsAsyncWithHttpInfo
     *
     * Busca restaurantes propios
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por nombre de los restaurantes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMyRestaurantsAsyncWithHttpInfo($accept_language = 'es', $n = null)
    {
        $returnType = '\Listae\Client\Model\SearchFilter';
        $request = $this->searchMyRestaurantsRequest($accept_language, $n);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchMyRestaurants'
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por nombre de los restaurantes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchMyRestaurantsRequest($accept_language = 'es', $n = null)
    {

        $resourcePath = '/restaurants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($n !== null) {
            $queryParams['n'] = ObjectSerializer::toQueryValue($n, null);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchPosts
     *
     * Búsqueda de publicaciones
     *
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  string $r2q Texto libre de búsqueda (optional)
     * @param  string $r2l Texto libre de localización geográfica (optional)
     * @param  string $r2r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $r2t Filtro de población (optional)
     * @param  string $r2c Filtro de país (optional)
     * @param  string $r2b Filtra publicaciones con negocio (valor True), sin negocio (valor False), sin filtrar (valor nulo) (optional)
     * @param  string $r2blog Filtro por blog de publicación, por ejemplo el valor “ http://example.listae.me/ ” sacaría solo publicaciones del sitio web de example (optional)
     * @param  string[] $r2cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $r2tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $r2lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $r2lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $r2dst Distancia en metros, radio del punto gps (optional)
     * @param  int $r2s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $r2sc Número de elementos por página (optional, default to 10)
     * @param  string $r2bss identificadores de negocios separados por comas, por ejemplo “sample-1,sample-2” te sacaría solo publicaciones de los restaurantes Sample 1 y Sample 2 (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\SearchPostFilter
     */
    public function searchPosts($accept_language = 'es', $r2q = null, $r2l = null, $r2r = null, $r2t = null, $r2c = null, $r2b = null, $r2blog = null, $r2cat = null, $r2tag = null, $r2lat = null, $r2lon = null, $r2dst = null, $r2s = null, $r2sc = '10', $r2bss = null)
    {
        list($response) = $this->searchPostsWithHttpInfo($accept_language, $r2q, $r2l, $r2r, $r2t, $r2c, $r2b, $r2blog, $r2cat, $r2tag, $r2lat, $r2lon, $r2dst, $r2s, $r2sc, $r2bss);
        return $response;
    }

    /**
     * Operation searchPostsWithHttpInfo
     *
     * Búsqueda de publicaciones
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $r2q Texto libre de búsqueda (optional)
     * @param  string $r2l Texto libre de localización geográfica (optional)
     * @param  string $r2r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $r2t Filtro de población (optional)
     * @param  string $r2c Filtro de país (optional)
     * @param  string $r2b Filtra publicaciones con negocio (valor True), sin negocio (valor False), sin filtrar (valor nulo) (optional)
     * @param  string $r2blog Filtro por blog de publicación, por ejemplo el valor “ http://example.listae.me/ ” sacaría solo publicaciones del sitio web de example (optional)
     * @param  string[] $r2cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $r2tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $r2lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $r2lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $r2dst Distancia en metros, radio del punto gps (optional)
     * @param  int $r2s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $r2sc Número de elementos por página (optional, default to 10)
     * @param  string $r2bss identificadores de negocios separados por comas, por ejemplo “sample-1,sample-2” te sacaría solo publicaciones de los restaurantes Sample 1 y Sample 2 (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\SearchPostFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchPostsWithHttpInfo($accept_language = 'es', $r2q = null, $r2l = null, $r2r = null, $r2t = null, $r2c = null, $r2b = null, $r2blog = null, $r2cat = null, $r2tag = null, $r2lat = null, $r2lon = null, $r2dst = null, $r2s = null, $r2sc = '10', $r2bss = null)
    {
        $returnType = '\Listae\Client\Model\SearchPostFilter';
        $request = $this->searchPostsRequest($accept_language, $r2q, $r2l, $r2r, $r2t, $r2c, $r2b, $r2blog, $r2cat, $r2tag, $r2lat, $r2lon, $r2dst, $r2s, $r2sc, $r2bss);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\SearchPostFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchPostsAsync
     *
     * Búsqueda de publicaciones
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $r2q Texto libre de búsqueda (optional)
     * @param  string $r2l Texto libre de localización geográfica (optional)
     * @param  string $r2r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $r2t Filtro de población (optional)
     * @param  string $r2c Filtro de país (optional)
     * @param  string $r2b Filtra publicaciones con negocio (valor True), sin negocio (valor False), sin filtrar (valor nulo) (optional)
     * @param  string $r2blog Filtro por blog de publicación, por ejemplo el valor “ http://example.listae.me/ ” sacaría solo publicaciones del sitio web de example (optional)
     * @param  string[] $r2cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $r2tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $r2lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $r2lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $r2dst Distancia en metros, radio del punto gps (optional)
     * @param  int $r2s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $r2sc Número de elementos por página (optional, default to 10)
     * @param  string $r2bss identificadores de negocios separados por comas, por ejemplo “sample-1,sample-2” te sacaría solo publicaciones de los restaurantes Sample 1 y Sample 2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPostsAsync($accept_language = 'es', $r2q = null, $r2l = null, $r2r = null, $r2t = null, $r2c = null, $r2b = null, $r2blog = null, $r2cat = null, $r2tag = null, $r2lat = null, $r2lon = null, $r2dst = null, $r2s = null, $r2sc = '10', $r2bss = null)
    {
        return $this->searchPostsAsyncWithHttpInfo($accept_language, $r2q, $r2l, $r2r, $r2t, $r2c, $r2b, $r2blog, $r2cat, $r2tag, $r2lat, $r2lon, $r2dst, $r2s, $r2sc, $r2bss)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchPostsAsyncWithHttpInfo
     *
     * Búsqueda de publicaciones
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $r2q Texto libre de búsqueda (optional)
     * @param  string $r2l Texto libre de localización geográfica (optional)
     * @param  string $r2r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $r2t Filtro de población (optional)
     * @param  string $r2c Filtro de país (optional)
     * @param  string $r2b Filtra publicaciones con negocio (valor True), sin negocio (valor False), sin filtrar (valor nulo) (optional)
     * @param  string $r2blog Filtro por blog de publicación, por ejemplo el valor “ http://example.listae.me/ ” sacaría solo publicaciones del sitio web de example (optional)
     * @param  string[] $r2cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $r2tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $r2lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $r2lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $r2dst Distancia en metros, radio del punto gps (optional)
     * @param  int $r2s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $r2sc Número de elementos por página (optional, default to 10)
     * @param  string $r2bss identificadores de negocios separados por comas, por ejemplo “sample-1,sample-2” te sacaría solo publicaciones de los restaurantes Sample 1 y Sample 2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPostsAsyncWithHttpInfo($accept_language = 'es', $r2q = null, $r2l = null, $r2r = null, $r2t = null, $r2c = null, $r2b = null, $r2blog = null, $r2cat = null, $r2tag = null, $r2lat = null, $r2lon = null, $r2dst = null, $r2s = null, $r2sc = '10', $r2bss = null)
    {
        $returnType = '\Listae\Client\Model\SearchPostFilter';
        $request = $this->searchPostsRequest($accept_language, $r2q, $r2l, $r2r, $r2t, $r2c, $r2b, $r2blog, $r2cat, $r2tag, $r2lat, $r2lon, $r2dst, $r2s, $r2sc, $r2bss);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchPosts'
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $r2q Texto libre de búsqueda (optional)
     * @param  string $r2l Texto libre de localización geográfica (optional)
     * @param  string $r2r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $r2t Filtro de población (optional)
     * @param  string $r2c Filtro de país (optional)
     * @param  string $r2b Filtra publicaciones con negocio (valor True), sin negocio (valor False), sin filtrar (valor nulo) (optional)
     * @param  string $r2blog Filtro por blog de publicación, por ejemplo el valor “ http://example.listae.me/ ” sacaría solo publicaciones del sitio web de example (optional)
     * @param  string[] $r2cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $r2tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $r2lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $r2lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $r2dst Distancia en metros, radio del punto gps (optional)
     * @param  int $r2s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $r2sc Número de elementos por página (optional, default to 10)
     * @param  string $r2bss identificadores de negocios separados por comas, por ejemplo “sample-1,sample-2” te sacaría solo publicaciones de los restaurantes Sample 1 y Sample 2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchPostsRequest($accept_language = 'es', $r2q = null, $r2l = null, $r2r = null, $r2t = null, $r2c = null, $r2b = null, $r2blog = null, $r2cat = null, $r2tag = null, $r2lat = null, $r2lon = null, $r2dst = null, $r2s = null, $r2sc = '10', $r2bss = null)
    {

        $resourcePath = '/search/posts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($r2q !== null) {
            $queryParams['r2q'] = ObjectSerializer::toQueryValue($r2q, null);
        }
        // query params
        if ($r2l !== null) {
            $queryParams['r2l'] = ObjectSerializer::toQueryValue($r2l, null);
        }
        // query params
        if ($r2r !== null) {
            $queryParams['r2r'] = ObjectSerializer::toQueryValue($r2r, null);
        }
        // query params
        if ($r2t !== null) {
            $queryParams['r2t'] = ObjectSerializer::toQueryValue($r2t, null);
        }
        // query params
        if ($r2c !== null) {
            $queryParams['r2c'] = ObjectSerializer::toQueryValue($r2c, null);
        }
        // query params
        if ($r2b !== null) {
            $queryParams['r2b'] = ObjectSerializer::toQueryValue($r2b, null);
        }
        // query params
        if ($r2blog !== null) {
            $queryParams['r2blog'] = ObjectSerializer::toQueryValue($r2blog, null);
        }
        // query params
        if (is_array($r2cat)) {
            $r2cat = ObjectSerializer::serializeCollection($r2cat, 'multi', true);
        }
        if ($r2cat !== null) {
            $queryParams['r2cat'] = ObjectSerializer::toQueryValue($r2cat, null);
        }
        // query params
        if (is_array($r2tag)) {
            $r2tag = ObjectSerializer::serializeCollection($r2tag, 'multi', true);
        }
        if ($r2tag !== null) {
            $queryParams['r2tag'] = ObjectSerializer::toQueryValue($r2tag, null);
        }
        // query params
        if ($r2lat !== null) {
            $queryParams['r2lat'] = ObjectSerializer::toQueryValue($r2lat, 'float');
        }
        // query params
        if ($r2lon !== null) {
            $queryParams['r2lon'] = ObjectSerializer::toQueryValue($r2lon, 'float');
        }
        // query params
        if ($r2dst !== null) {
            $queryParams['r2dst'] = ObjectSerializer::toQueryValue($r2dst, 'int64');
        }
        // query params
        if ($r2s !== null) {
            $queryParams['r2s'] = ObjectSerializer::toQueryValue($r2s, 'int64');
        }
        // query params
        if ($r2sc !== null) {
            $queryParams['r2sc'] = ObjectSerializer::toQueryValue($r2sc, 'int64');
        }
        // query params
        if ($r2bss !== null) {
            $queryParams['r2bss'] = ObjectSerializer::toQueryValue($r2bss, null);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRestaurantReviews
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  string $f Filtro de la paginacion (all, todos; booking, vinculados con reservas, other, no vinculados con reservas, por defecto all) (optional)
     * @param  string $bo Filtro por la propiedad de la opinion (true, realizado en el sitio web del negocio; false, realizado fuera del sitio web del negocio; null, sin filtrar) (optional)
     * @param  int $p Número de la pagina a obtener (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\PaginationReviewList
     */
    public function searchRestaurantReviews($restaurant_id, $accept_language = 'es', $f = null, $bo = null, $p = null)
    {
        list($response) = $this->searchRestaurantReviewsWithHttpInfo($restaurant_id, $accept_language, $f, $bo, $p);
        return $response;
    }

    /**
     * Operation searchRestaurantReviewsWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $f Filtro de la paginacion (all, todos; booking, vinculados con reservas, other, no vinculados con reservas, por defecto all) (optional)
     * @param  string $bo Filtro por la propiedad de la opinion (true, realizado en el sitio web del negocio; false, realizado fuera del sitio web del negocio; null, sin filtrar) (optional)
     * @param  int $p Número de la pagina a obtener (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\PaginationReviewList, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRestaurantReviewsWithHttpInfo($restaurant_id, $accept_language = 'es', $f = null, $bo = null, $p = null)
    {
        $returnType = '\Listae\Client\Model\PaginationReviewList';
        $request = $this->searchRestaurantReviewsRequest($restaurant_id, $accept_language, $f, $bo, $p);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\PaginationReviewList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRestaurantReviewsAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $f Filtro de la paginacion (all, todos; booking, vinculados con reservas, other, no vinculados con reservas, por defecto all) (optional)
     * @param  string $bo Filtro por la propiedad de la opinion (true, realizado en el sitio web del negocio; false, realizado fuera del sitio web del negocio; null, sin filtrar) (optional)
     * @param  int $p Número de la pagina a obtener (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRestaurantReviewsAsync($restaurant_id, $accept_language = 'es', $f = null, $bo = null, $p = null)
    {
        return $this->searchRestaurantReviewsAsyncWithHttpInfo($restaurant_id, $accept_language, $f, $bo, $p)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRestaurantReviewsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $f Filtro de la paginacion (all, todos; booking, vinculados con reservas, other, no vinculados con reservas, por defecto all) (optional)
     * @param  string $bo Filtro por la propiedad de la opinion (true, realizado en el sitio web del negocio; false, realizado fuera del sitio web del negocio; null, sin filtrar) (optional)
     * @param  int $p Número de la pagina a obtener (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRestaurantReviewsAsyncWithHttpInfo($restaurant_id, $accept_language = 'es', $f = null, $bo = null, $p = null)
    {
        $returnType = '\Listae\Client\Model\PaginationReviewList';
        $request = $this->searchRestaurantReviewsRequest($restaurant_id, $accept_language, $f, $bo, $p);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRestaurantReviews'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     * @param  string $f Filtro de la paginacion (all, todos; booking, vinculados con reservas, other, no vinculados con reservas, por defecto all) (optional)
     * @param  string $bo Filtro por la propiedad de la opinion (true, realizado en el sitio web del negocio; false, realizado fuera del sitio web del negocio; null, sin filtrar) (optional)
     * @param  int $p Número de la pagina a obtener (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRestaurantReviewsRequest($restaurant_id, $accept_language = 'es', $f = null, $bo = null, $p = null)
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling searchRestaurantReviews'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/reviews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($f !== null) {
            $queryParams['f'] = ObjectSerializer::toQueryValue($f, null);
        }
        // query params
        if ($bo !== null) {
            $queryParams['bo'] = ObjectSerializer::toQueryValue($bo, null);
        }
        // query params
        if ($p !== null) {
            $queryParams['p'] = ObjectSerializer::toQueryValue($p, 'int32');
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRestaurants
     *
     * Búsqueda de restaurantes
     *
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $iac Ignora los filtros ocultos de la API (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\SearchFilter
     */
    public function searchRestaurants($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $iac = null, $slugs = null, $geocodes = null)
    {
        list($response) = $this->searchRestaurantsWithHttpInfo($accept_language, $n, $q, $l, $r, $t, $c, $cat, $tag, $lat, $lon, $dst, $s, $sc, $hcl, $iac, $slugs, $geocodes);
        return $response;
    }

    /**
     * Operation searchRestaurantsWithHttpInfo
     *
     * Búsqueda de restaurantes
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $iac Ignora los filtros ocultos de la API (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\SearchFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRestaurantsWithHttpInfo($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $iac = null, $slugs = null, $geocodes = null)
    {
        $returnType = '\Listae\Client\Model\SearchFilter';
        $request = $this->searchRestaurantsRequest($accept_language, $n, $q, $l, $r, $t, $c, $cat, $tag, $lat, $lon, $dst, $s, $sc, $hcl, $iac, $slugs, $geocodes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\SearchFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRestaurantsAsync
     *
     * Búsqueda de restaurantes
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $iac Ignora los filtros ocultos de la API (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRestaurantsAsync($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $iac = null, $slugs = null, $geocodes = null)
    {
        return $this->searchRestaurantsAsyncWithHttpInfo($accept_language, $n, $q, $l, $r, $t, $c, $cat, $tag, $lat, $lon, $dst, $s, $sc, $hcl, $iac, $slugs, $geocodes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRestaurantsAsyncWithHttpInfo
     *
     * Búsqueda de restaurantes
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $iac Ignora los filtros ocultos de la API (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRestaurantsAsyncWithHttpInfo($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $iac = null, $slugs = null, $geocodes = null)
    {
        $returnType = '\Listae\Client\Model\SearchFilter';
        $request = $this->searchRestaurantsRequest($accept_language, $n, $q, $l, $r, $t, $c, $cat, $tag, $lat, $lon, $dst, $s, $sc, $hcl, $iac, $slugs, $geocodes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRestaurants'
     *
     * @param  string $accept_language (optional, default to es)
     * @param  string $n Filtro por el nombre del restaurante (optional)
     * @param  string $q Texto libre de búsqueda (optional)
     * @param  string $l Texto libre de localización geográfica (optional)
     * @param  string $r Filtro de región (Provincia / Región / Estado) (optional)
     * @param  string $t Filtro de población (optional)
     * @param  string $c Filtro de país (optional)
     * @param  string[] $cat Filtro por categoría/s, con los distintos identificadores de categoría para filtrar (optional)
     * @param  string[] $tag Filtro por etiqueta/s, con los distintas etiquetas para filtrar (optional)
     * @param  float $lat Latitúd para buscar cerca de un punto gps (optional)
     * @param  float $lon Longitúd para buscar cerca de un punto gps (optional)
     * @param  int $dst Distancia en metros, radio del punto gps (optional)
     * @param  int $s Indice del primer elemento de la pagina por el cual estamos consultando, por ejemplo, si se trata de una paginación de 10 en 10 valdría; 0 para la primera página, 10 para la segunda, 20 para la tercera, (n - 1)*10 para la página n…. (optional)
     * @param  int $sc Número de elementos por página (optional, default to 10)
     * @param  string $hcl Filtro de categorias separados por comas ocultos al usuario que realiza la busqueda (optional)
     * @param  string $iac Ignora los filtros ocultos de la API (optional)
     * @param  string $slugs Filtro de identificadores de negocio separados por comas (optional)
     * @param  string $geocodes Google PlaceIds separados por espacios (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRestaurantsRequest($accept_language = 'es', $n = null, $q = null, $l = null, $r = null, $t = null, $c = null, $cat = null, $tag = null, $lat = null, $lon = null, $dst = null, $s = null, $sc = '10', $hcl = null, $iac = null, $slugs = null, $geocodes = null)
    {

        $resourcePath = '/search/restaurants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($n !== null) {
            $queryParams['n'] = ObjectSerializer::toQueryValue($n, null);
        }
        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q, null);
        }
        // query params
        if ($l !== null) {
            $queryParams['l'] = ObjectSerializer::toQueryValue($l, null);
        }
        // query params
        if ($r !== null) {
            $queryParams['r'] = ObjectSerializer::toQueryValue($r, null);
        }
        // query params
        if ($t !== null) {
            $queryParams['t'] = ObjectSerializer::toQueryValue($t, null);
        }
        // query params
        if ($c !== null) {
            $queryParams['c'] = ObjectSerializer::toQueryValue($c, null);
        }
        // query params
        if (is_array($cat)) {
            $cat = ObjectSerializer::serializeCollection($cat, 'multi', true);
        }
        if ($cat !== null) {
            $queryParams['cat'] = ObjectSerializer::toQueryValue($cat, null);
        }
        // query params
        if (is_array($tag)) {
            $tag = ObjectSerializer::serializeCollection($tag, 'multi', true);
        }
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag, null);
        }
        // query params
        if ($lat !== null) {
            $queryParams['lat'] = ObjectSerializer::toQueryValue($lat, 'float');
        }
        // query params
        if ($lon !== null) {
            $queryParams['lon'] = ObjectSerializer::toQueryValue($lon, 'float');
        }
        // query params
        if ($dst !== null) {
            $queryParams['dst'] = ObjectSerializer::toQueryValue($dst, 'int64');
        }
        // query params
        if ($s !== null) {
            $queryParams['s'] = ObjectSerializer::toQueryValue($s, 'int64');
        }
        // query params
        if ($sc !== null) {
            $queryParams['sc'] = ObjectSerializer::toQueryValue($sc, 'int64');
        }
        // query params
        if ($hcl !== null) {
            $queryParams['hcl'] = ObjectSerializer::toQueryValue($hcl, null);
        }
        // query params
        if ($iac !== null) {
            $queryParams['iac'] = ObjectSerializer::toQueryValue($iac, null);
        }
        // query params
        if ($slugs !== null) {
            $queryParams['slugs'] = ObjectSerializer::toQueryValue($slugs, null);
        }
        // query params
        if ($geocodes !== null) {
            $queryParams['geocodes'] = ObjectSerializer::toQueryValue($geocodes, null);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation simulateBooking
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language accept_language (optional, default to es)
     * @param  \DateTime $date Fecha para la reserva (formato yyyy-mm-dd) (optional)
     * @param  string $time Hora para la reserva (formato hh:mm) (optional)
     * @param  int $bkrs Número de comensales para la reserva (optional)
     * @param  string $da Identificador de la sala donde se pretende reservar (optional)
     * @param  string $menu Identificador del menu que se pretende reservar (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Listae\Client\Model\BookingCfg
     */
    public function simulateBooking($restaurant_id, $accept_language = 'es', $date = null, $time = null, $bkrs = null, $da = null, $menu = null)
    {
        list($response) = $this->simulateBookingWithHttpInfo($restaurant_id, $accept_language, $date, $time, $bkrs, $da, $menu);
        return $response;
    }

    /**
     * Operation simulateBookingWithHttpInfo
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     * @param  \DateTime $date Fecha para la reserva (formato yyyy-mm-dd) (optional)
     * @param  string $time Hora para la reserva (formato hh:mm) (optional)
     * @param  int $bkrs Número de comensales para la reserva (optional)
     * @param  string $da Identificador de la sala donde se pretende reservar (optional)
     * @param  string $menu Identificador del menu que se pretende reservar (optional)
     *
     * @throws \Listae\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Listae\Client\Model\BookingCfg, HTTP status code, HTTP response headers (array of strings)
     */
    public function simulateBookingWithHttpInfo($restaurant_id, $accept_language = 'es', $date = null, $time = null, $bkrs = null, $da = null, $menu = null)
    {
        $returnType = '\Listae\Client\Model\BookingCfg';
        $request = $this->simulateBookingRequest($restaurant_id, $accept_language, $date, $time, $bkrs, $da, $menu);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listae\Client\Model\BookingCfg',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation simulateBookingAsync
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     * @param  \DateTime $date Fecha para la reserva (formato yyyy-mm-dd) (optional)
     * @param  string $time Hora para la reserva (formato hh:mm) (optional)
     * @param  int $bkrs Número de comensales para la reserva (optional)
     * @param  string $da Identificador de la sala donde se pretende reservar (optional)
     * @param  string $menu Identificador del menu que se pretende reservar (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function simulateBookingAsync($restaurant_id, $accept_language = 'es', $date = null, $time = null, $bkrs = null, $da = null, $menu = null)
    {
        return $this->simulateBookingAsyncWithHttpInfo($restaurant_id, $accept_language, $date, $time, $bkrs, $da, $menu)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation simulateBookingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     * @param  \DateTime $date Fecha para la reserva (formato yyyy-mm-dd) (optional)
     * @param  string $time Hora para la reserva (formato hh:mm) (optional)
     * @param  int $bkrs Número de comensales para la reserva (optional)
     * @param  string $da Identificador de la sala donde se pretende reservar (optional)
     * @param  string $menu Identificador del menu que se pretende reservar (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function simulateBookingAsyncWithHttpInfo($restaurant_id, $accept_language = 'es', $date = null, $time = null, $bkrs = null, $da = null, $menu = null)
    {
        $returnType = '\Listae\Client\Model\BookingCfg';
        $request = $this->simulateBookingRequest($restaurant_id, $accept_language, $date, $time, $bkrs, $da, $menu);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'simulateBooking'
     *
     * @param  string $restaurant_id El identificador del restaurante. (required)
     * @param  string $accept_language (optional, default to es)
     * @param  \DateTime $date Fecha para la reserva (formato yyyy-mm-dd) (optional)
     * @param  string $time Hora para la reserva (formato hh:mm) (optional)
     * @param  int $bkrs Número de comensales para la reserva (optional)
     * @param  string $da Identificador de la sala donde se pretende reservar (optional)
     * @param  string $menu Identificador del menu que se pretende reservar (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function simulateBookingRequest($restaurant_id, $accept_language = 'es', $date = null, $time = null, $bkrs = null, $da = null, $menu = null)
    {
        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling simulateBooking'
            );
        }

        $resourcePath = '/restaurants/{restaurant-id}/booking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date');
        }
        // query params
        if ($time !== null) {
            $queryParams['time'] = ObjectSerializer::toQueryValue($time, null);
        }
        // query params
        if ($bkrs !== null) {
            $queryParams['bkrs'] = ObjectSerializer::toQueryValue($bkrs, 'int32');
        }
        // query params
        if ($da !== null) {
            $queryParams['da'] = ObjectSerializer::toQueryValue($da, null);
        }
        // query params
        if ($menu !== null) {
            $queryParams['menu'] = ObjectSerializer::toQueryValue($menu, null);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurant-id' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-listae-key');
        if ($apiKey !== null) {
            $headers['x-listae-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
